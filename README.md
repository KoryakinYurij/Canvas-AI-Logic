# Интерактивный ИИ‑канвас

Краткое формальное описание проекта: Интерактивный ИИ‑канвас, который принимает произвольную информацию от пользователя (тексты, тезисы, документы, идеи) и автоматически преобразует её в визуальный граф из нод и связей, формируя логичную, эстетичную карту знаний, которую можно дорабатывать в диалоге с ИИ.

## Архитектура

Для этого проекта предлагается не стандартная монолитная архитектура, а многослойная система, вдохновлённая Clean Architecture и адаптированная под Atomic Design. Это позволит «скейлить» приложение, меняя части независимо друг от друга.

Вот высокоуровневая схема (от «глупого» интерфейса к «умному» ядру):

### Уровень 1: Presentation Layer (Витрина / Атомы и Молекулы)

Этот слой отвечает только за рендеринг. Он ничего не знает о том, откуда берутся данные. Здесь царит чистый Atomic Design.

*   **Atoms (UI-Kit):** Кнопки, иконки портов, базовые геометрические фигуры (прямоугольник ноды), спиннеры.
    *   **Принцип:** Максимальная тупость. Принимают `props`, отдают события.
*   **Molecules (Composite UI):**
    *   `NodeHeader`: (Icon + Title + Toolbar).
    *   `PortSocket`: (Circle + Label + ValidationStateColor).
    *   `ConnectionLine`: (SVG Path + Animation).
*   **Organisms (Node Visuals):**
    *   `VisualNodeCard`: Это визуальная оболочка любой ноды. Она собирает Header, Body и Ports в единый красивый прямоугольник с тенями и скруглениями. Внимание: здесь нет логики, только вёрстка!

### Уровень 2: Widget Layer (Сцена / Шаблоны)

Здесь происходит магия соединения UI с действиями пользователя.

*   **Smart Components (Containers):**
    *   `NodeContainer`: Обертка, которая подключается к стейту, получает координаты (x, y) и данные ноды, а затем рендерит внутри себя `VisualNodeCard`.
    *   `CanvasWidget`: Компонент, который управляет зумом (zoom), панорамированием (pan) и виртуализацией (чтобы не рендерить 1000 нод, если видно только 10).
*   **Layout Engines (AI & Algorithms):**
    *   Это отдельные модули, которые рассчитывают координаты.
    *   `AutoLayoutService`: Получает список нод, прогоняет через алгоритм (например, Dagre или Elkjs) и возвращает новые координаты, чтобы граф стал «красивым».

### Уровень 3: Domain Layer (Бизнес-логика / Сущности)

Самое важное. Здесь живут правила твоего приложения.

*   **Node Entities (Классы/Модели):**
    *   Каждый тип ноды — это класс (или объект), который описывает свои правила: «Я нода-фильтр, у меня должен быть 1 вход и 2 выхода».
    *   Это позволяет ИИ понимать, какие ноды можно соединять, а какие нет (валидация связей).
*   **Graph Model:**
    *   Единый источник правды. JSON-объект, описывающий весь граф: `{ nodes: [], edges: [] }`.

### Уровень 4: Infrastructure Layer (Связь с миром)

*   **AI Connector:**
    *   Сервис, который ходит в API (OpenAI/Claude), отправляет туда текстовый запрос пользователя («Сделай схему маркетинга») и получает обратно JSON-структуру графа.
    *   Он преобразует ответ ИИ в понятные для Domain Layer сущности.

## Поток данных (Data Flow)

1.  **User Input:** Пользователь пишет: «Хочу схему воронки продаж».
2.  **AI Processing (Infrastructure):** ИИ генерирует абстрактный список шагов.
3.  **Mapping (Domain):** Система превращает эти шаги в конкретные Node Entities (например, 3 ноды "Action" и 1 нода "Condition").
4.  **Layout (Widget Layer):** Алгоритм лейаута расставляет им красивые координаты x/y.
5.  **Rendering (Presentation):** React отрисовывает `NodeContainer` -> `VisualNodeCard` -> Molecules -> Atoms.

## Преимущества архитектуры

*   **Визуальная модульность:** Хочешь изменить стиль всех портов? Меняешь 1 файл в Atoms.
*   **Логическая модульность:** Хочешь добавить новый тип ноды? Создаешь новую сущность в Domain, не ломая старые.
*   **Изоляция ИИ:** Если завтра выйдет GPT-6, ты меняешь только AI Connector, всё остальное приложение остается прежним.
